# Docker

## Alt-tab guide

Docker - продукт, позволяющий создавать легковесные виртуальные машины. Он облегчает развертывание ПО, так как все необходимые зависимости уже находятся внутри.

Изображение (image) - описание виртуальной машины: ОС, предустановленные программы, файлы. Как правило, изображения проименованы как &lt;название&gt;:&lt;метка&gt;

Контейнер (container) - это сама виртуальная машина. Она создаётся на основании изображения.

Контейнер изолирован от хоста - то есть, у него своя ОС, своё окружение и установленные программы. Он не может взаимодействовать с файловой системой хоста (и наоборот) без отдельных разрешений. Также, входящие соединения (например, FTP, или HTTP) в контейнер не будут пропускаться по умолчанию (исходящие - будут; это полезно при установке дополнительных программ, например).

К контейнерам следует относиться как к нечту эфемерному; в них нельзя хранить важную информацию.

## Dockerfile

Изображения создаются с помощью Dockerfile - файла, который содержит инструкцию по сборке (build) изображения файлов посредством команд.

Формат файл - каждая строка - это команда. Пример Dockerfile:

```
FROM python:3.6

RUN mkdir app

COPY ./sample.py /app/

EXPOSE 80

CMD python3 /app/sample.py
```

[Официальная дока + полный список команд](https://docs.docker.com/engine/reference/builder/#usage)

Типовые команды:

**`FROM <имя изображения>`**

Базирует изображение на основе какого-то другого (как правило, первая команда в файле). Примеры:

`FROM ubuntu:14.04` - базирует на основе Ubuntu 14

`FROM python:3.6` - базируется на основе Ubuntu с предустановленной в нём python 3.6.

**`RUN <command>`** - исполняет команду в контейнере (команды запускаются от root) NB: перед тем, как запускать apt-get install, надо обновить список пакетов через apt-get update. Примеры:

`RUN apt-get update && apt-get install python3`

`RUN mkdir app`

**`COPY`** - копирует в изображение файл или директорию с хоста. Можно работать только с директорией, где расположен Dockerfile, или поддиректориями (нельзя уходить вверх). Пример:

`COPY ./sample.py /app/`



**`CMD`** - указывает, какую команду нужно выполнить внутри создании контейнера после создания его по этому изображению (команды запускаются от root). Пример:

`CMD python3 /app/sample.py`

## Команды докера

[Полный список](https://docs.docker.com/engine/reference/commandline/docker/#child-commands)

(опциональные части в [ ] ):



docker build &lt;директория с Dockerfile&gt; [-t &lt;изображение&gt;][:&lt;метка&gt;] - собирает изображение; опционально назначает ему имя



docker run &lt;изображение&gt;[:&lt;метка&gt;] - создает контейнер на основе изображения



docker ps [-a] - выводит список запущенных контейнеров (-a - и в том числе и остановленных)



docker logs &lt;контейнер&gt; - выводит stdout/stderr контейнера



docker stop &lt;контейнер&gt; - приостанавливает контейнер



docker start &lt;контейнер&gt; - продолжает контейнер



docker kill &lt;контейнер&gt; - уничтожает контейнер



docker system prune - удаляет неиспользуемые контейнеры и изображения.

## Взаимодействие с контейнером

Исполняемое в контейнере изолировано от хоста. Есть несколько типовых способов взаимодействия внешнего мира с ним:

- “подключить” к контейнеру директорию или файл, открыв ему доступ к ним и позволив ему их редактировать их
- открыть порт, позволив входящие подключения.
- взаимодействие с общим хранилищем данных. Из контейнера разрешены исходящие соединения, и он может подключаться к сервисам - например, к базам данным.


Флаг [-p Порт_в_хосте:Порт_в_контейнере]  при запуске (docker run) позволяет входящие соединения (HTTP/FTP/…) к контейнеру.



Флаг [-v Путь_в_хосте:Путь_в_Контейнере]  при запуске (docker run)  монтирует директорию хоста к файловой системе контейнера. То есть все файлы и директории по указанному пути хоста будут отражены по соответствующему пути в контейнере (или аналогично с отдельными файлами); это отражение двухстороннее. Путь должен быть абсолютным. Пример:

docker run -v /home/user/myfiles/ /appfiles/ myimage - в контейнере появится директория /appfiles/ , в которой будут все файлы и поддиректории /home/user/myfiles/ . Все изменения, вносимые контейнером, будут видны хосту (в т.ч. в процессе работы).

[Полная и подробная документация по Volumes](https://docs.docker.com/engine/admin/volumes/volumes/#choose-the--v-or-mount-flag)

## Дебаг

Команды, полезные для дебага:

docker run … -it /bin/bash - открывает терминал прямо в контейнере. Флажки -it запускают контейнер в интерактивном режиме, а /bin/bash указывает, что надо запустить консоль bash.

docker run … -d - флажок -d запускает контейнер в фоновом режиме. Это полезно, когда выполнение может затягиваться. “Присоединиться” к такому контейнеру можно docker attach &lt;контейнер&gt;.

docker logs &lt;контейнер&gt; - выводит stdout (print’ы) и stderr (exception’ы и warning’и) команды контейнера. Флажок -f позволяет “следить” за логами.

## Задачи

### А

Скрипт script_a.py умеет складывать числа. Этот скрипт принимает два аргумента командной строки - путь к файлу с данными, и путь файлу, в который будет записана сумма.

Создайте образ, который будет запускать этот скрипт. Предполагается, что при создании контейнера директория /hostfiles/ будет примонтирована к контейнеру. Файл с данными будет расположен по пути /hostfiles/input.txt , результирующий файл должен быть записан в /hostfiles/output.txt .

Для тестирования можно использовать команды (из директории с проектом):

docker build . -t MyImage

docker run -v &lt;полный путь к файлам&gt;/:/hostfiles/ MyImage

### B

Скрипт script_b.py умеет предсказывать значения. Этот скрипт принимает три аргумента командной строки

Путь к файлу с тренировочными данными (предполагается, что это tsv-файл, и последний столбец - целевая функция)

Путь к файлу с тестовыми данными (это tsv-файл с такими же столбцами, что и тренировочный файл, но без столбца с целевой функцией

Путь к файлу, в который будут записаны ответы (одна строка - один ответ)

Создайте образ, который будет запускать этот скрипт. Предполагается, что при создании контейнера директория /hostfiles/ будет примонтирована к контейнеру. Файл с тренировочным множеством будет расположен по пути /hostfiles/train.tsv , с тестовым /hostfiles/test.tsv , результат должен быть записан в /hostfiles/output.txt .

Команды для сборки изображения и тестирования напишите самостоятельно.

**BONUS POINTS**:

Сделайте так, чтобы модель выдавала MSE меньше 1.0.

### C

Создайте образ, который будет принимать запросы на 80й порт, и иметь следующие пути API:

GET /predict?a=&lt;a&gt;&b=&lt;b&gt;&c=&lt;c&gt;... - должен возвратить JSON вида {“prediction”: &lt;value&gt;} с предсказанием по указанным значениям фичей

Тренировочные данные для регрессии на вход должны читаться из файла /hostfiles/train.txt

**BONUS POINTS**:

Сделайте так, чтобы путь к файлу с тренировочными данными читался из окружения (переменная TRAIN_FILE_PATH).

### D

Создать сервис, который будет принимать запросы на 80й порт, и иметь следующие пути API:

POST /action - запоминает данные о событии. В теле запроса передается JSON с данными вида {a: &lt;a&gt;, b: &lt;b&gt;, c: &lt;c&gt;, … target: &lt;target&gt;} ;

POST /build - тренирует модель.

GET /predict?a=&lt;a&gt;&b=&lt;b&gt;&c=&lt;c&gt;... - получает результаты предсказания.

**BONUS POINT**:

Сделайте так, что при повторных созданиях контейнера из образа загружалась последняя построенная модель. Данные для доступа к БД будут переданы в окружение, URI Postgres будет записан в environment как POSTGRES_URI.

**EXTRA BONUS POINTS**:

Сделайте так, чтобы в добавок к сохранению, модель дотренировывалась после каждой добавленной записи, т.е. дообучалась в онлайн-режиме (предполагается, что в этой задаче зависимость хорошо аппроксимируется линейной функцией).
